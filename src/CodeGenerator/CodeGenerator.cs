using System.Collections.Immutable;
using System.Text;
using RealGoodApps.BlazorJavascript.CodeGenerator.Models;

namespace RealGoodApps.BlazorJavascript.CodeGenerator
{
    public class CodeGenerator
    {
        private readonly ParsedInfo _parsedInfo;
        private readonly string _outputDirectory;

        public CodeGenerator(
            ParsedInfo parsedInfo,
            string outputDirectory)
        {
            _parsedInfo = parsedInfo;
            _outputDirectory = outputDirectory;
        }

        public void Generate()
        {
            foreach (var interfaceInfo in _parsedInfo.Interfaces)
            {
                var contents = GenerateInterfaceFileContents(interfaceInfo);

                var interfaceOutputPath = Path.Combine(
                    _outputDirectory,
                    $"{interfaceInfo.Name}.cs");

                if (File.Exists(interfaceOutputPath))
                {
                    throw new Exception($"File already exists: {interfaceOutputPath}");
                }

                File.WriteAllText(interfaceOutputPath, contents);
            }
        }

        private string GenerateInterfaceFileContents(InterfaceInfo interfaceInfo)
        {
            var stringBuilder = new StringBuilder();

            stringBuilder.AppendLine("/// <auto-generated />");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("namespace RealGoodApps.BlazorJavascript.Interop.Interfaces");
            stringBuilder.AppendLine("{");

            stringBuilder.Append($"  public interface {interfaceInfo.Name}");

            if (interfaceInfo.ExtractTypeParametersResult.TypeParameters.Any())
            {
                stringBuilder.Append('<');

                stringBuilder.Append(string.Join(", ", interfaceInfo.ExtractTypeParametersResult.TypeParameters
                    .Select(typeParameter => typeParameter.Name)));

                stringBuilder.Append('>');
            }

            var extendsList = interfaceInfo.ExtendsList
                .Select(extendTypeInfo => extendTypeInfo.Single)
                .WhereNotNull()
                .Select(extendSingleType =>
                {
                    var fullName = new StringBuilder();
                    fullName.Append(extendSingleType.Name);

                    var typeArguments = extendSingleType
                        .TypeArguments
                        .Select(typeArgument => typeArgument.Single)
                        .WhereNotNull()
                        .ToImmutableList();

                    if (typeArguments.Any())
                    {
                        fullName.Append('<');
                        fullName.Append(string.Join(",", typeArguments.Select(typeArgument => typeArgument.Name)));
                        fullName.Append('>');
                    }

                    return fullName.ToString();
                })
                .Append("IJSObject")
                .ToImmutableList();
            stringBuilder.Append($" : {string.Join(", ", extendsList)}");
            stringBuilder.Append(Environment.NewLine);

            stringBuilder.AppendLine("  {");

            foreach (var methodInfo in interfaceInfo.Methods)
            {
                // FIXME: We are skipping any methods that are not simple enough for a 1 to 1 translation.
                //        For example, nothing with generics, union types, intersection types, or function parameters.
                if (methodInfo.ExtractTypeParametersResult.TypeParameters.Any())
                {
                    continue;
                }

                if (methodInfo.ReturnType.Single == null
                    || methodInfo.ReturnType.Single.IsUnhandled
                    || methodInfo.ReturnType.Single.TypeArguments.Any()
                    || string.IsNullOrWhiteSpace(methodInfo.ReturnType.Single.Name))
                {
                    continue;
                }

                if (methodInfo.Parameters.Any(parameterInfo => parameterInfo.Type.Single == null
                                                               || parameterInfo.Type.Single.IsUnhandled
                                                               || parameterInfo.Type.Single.TypeArguments.Any()
                                                               || string.IsNullOrWhiteSpace(parameterInfo.Type.Single.Name)))
                {
                    continue;
                }

                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append("    ");
                stringBuilder.Append(methodInfo.ReturnType.Single.GetNameForCSharp());
                stringBuilder.Append(' ');
                stringBuilder.Append(methodInfo.GetNameForCSharp());
                stringBuilder.Append('(');

                var isFirst = true;

                foreach (var parameterInfo in methodInfo.Parameters)
                {
                    if (!isFirst)
                    {
                        stringBuilder.Append(", ");
                    }

                    stringBuilder.Append(parameterInfo.Type.Single?.GetNameForCSharp());
                    stringBuilder.Append(' ');
                    stringBuilder.Append(parameterInfo.GetNameForCSharp());
                    isFirst = false;
                }

                stringBuilder.Append(");");
                stringBuilder.Append(Environment.NewLine);
            }

            stringBuilder.AppendLine("  }");
            stringBuilder.AppendLine("}");

            return stringBuilder.ToString();
        }
    }
}
