using System.Collections.Immutable;
using System.Text;
using RealGoodApps.BlazorJavascript.CodeGenerator.Models;

namespace RealGoodApps.BlazorJavascript.CodeGenerator
{
    public class CodeGenerator
    {
        private readonly ParsedInfo _parsedInfo;
        private readonly string _outputDirectory;

        public CodeGenerator(
            ParsedInfo parsedInfo,
            string outputDirectory)
        {
            _parsedInfo = parsedInfo;
            _outputDirectory = outputDirectory;
        }

        public void Generate()
        {
            foreach (var interfaceInfo in _parsedInfo.Interfaces)
            {
                var contents = GenerateInterfaceFileContents(interfaceInfo);

                var interfaceOutputPath = Path.Combine(
                    _outputDirectory,
                    $"I{interfaceInfo.Name}.cs");

                if (File.Exists(interfaceOutputPath))
                {
                    throw new Exception($"File already exists: {interfaceOutputPath}");
                }

                File.WriteAllText(interfaceOutputPath, contents);
            }
        }

        private string GenerateInterfaceFileContents(InterfaceInfo interfaceInfo)
        {
            var stringBuilder = new StringBuilder();

            stringBuilder.AppendLine("/// <auto-generated />");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.BuiltIns;");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("namespace RealGoodApps.BlazorJavascript.Interop.Interfaces");
            stringBuilder.AppendLine("{");

            stringBuilder.Append($"{Indent(1)}public interface I{interfaceInfo.Name}");

            if (interfaceInfo.ExtractTypeParametersResult.TypeParameters.Any())
            {
                stringBuilder.Append('<');

                stringBuilder.Append(string.Join(", ", interfaceInfo.ExtractTypeParametersResult.TypeParameters
                    .Select(typeParameter => typeParameter.Name)));

                stringBuilder.Append('>');
            }

            var extendsList = interfaceInfo.ExtendsList
                .Select(extendTypeInfo => extendTypeInfo)
                .Where(extendTypeInfo => extendTypeInfo.Single != null)
                .Select(GetRenderedTypeName)
                .Append("IJSObject")
                .ToImmutableList();
            stringBuilder.Append($" : {string.Join(", ", extendsList)}");
            stringBuilder.Append(Environment.NewLine);

            stringBuilder.AppendLine(Indent(1) + "{");

            foreach (var methodInfo in interfaceInfo.Body.Methods)
            {
                // FIXME: We are skipping any methods that are not simple enough for a 1 to 1 translation.
                //        For example, nothing with generics, union types, intersection types, or function parameters.
                if (methodInfo.ExtractTypeParametersResult.TypeParameters.Any())
                {
                    continue;
                }

                if (IsFinalTypeSimpleEnoughToRender(methodInfo.ReturnType))
                {
                    continue;
                }

                if (methodInfo.Parameters.Any(parameterInfo => IsFinalTypeSimpleEnoughToRender(parameterInfo.Type)))
                {
                    continue;
                }

                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));
                stringBuilder.Append(GetRenderedTypeName(methodInfo.ReturnType));
                stringBuilder.Append(' ');
                stringBuilder.Append(methodInfo.GetNameForCSharp());
                stringBuilder.Append('(');

                var isFirst = true;

                foreach (var parameterInfo in methodInfo.Parameters)
                {
                    if (!isFirst)
                    {
                        stringBuilder.Append(", ");
                    }

                    stringBuilder.Append(GetRenderedTypeName(parameterInfo.Type));
                    stringBuilder.Append(' ');
                    stringBuilder.Append(parameterInfo.GetNameForCSharp());
                    isFirst = false;
                }

                stringBuilder.Append(");");
                stringBuilder.Append(Environment.NewLine);
            }

            stringBuilder.AppendLine(Indent(1) + "}");
            stringBuilder.AppendLine("}");

            return stringBuilder.ToString();
        }

        private static string Indent(int levels)
        {
            var indentationBuilder = new StringBuilder();

            for (int level = 1; level <= levels; level++)
            {
                indentationBuilder.Append("    ");
            }

            return indentationBuilder.ToString();
        }

        private bool IsFinalTypeSimpleEnoughToRender(TypeInfo parameterInfoType)
        {
            // FIXME: Eventually, this method shouldn't really exist. It is just used to prevent us from having to handle complex type cases right now.
            var finalTypeInfo = ProcessTypeAliases(parameterInfoType);

            return finalTypeInfo.Single == null
                   || finalTypeInfo.Single.IsUnhandled
                   || finalTypeInfo.Single.TypeArguments.Any()
                   || string.IsNullOrWhiteSpace(finalTypeInfo.Single.Name);
        }

        private string GetRenderedTypeName(TypeInfo typeInfo)
        {
            var finalTypeInfo = ProcessTypeAliases(typeInfo);

            var singleTypeInfo = finalTypeInfo.Single;

            if (singleTypeInfo == null)
            {
                throw new Exception("The type name can not be rendered properly due to complexity.");
            }

            var fullName = new StringBuilder();
            fullName.Append(singleTypeInfo.GetNameForCSharp(_parsedInfo.Interfaces));

            var typeArguments = singleTypeInfo
                .TypeArguments
                .Select(typeArgument => typeArgument.Single)
                .WhereNotNull()
                .ToImmutableList();

            if (typeArguments.Any())
            {
                fullName.Append('<');
                fullName.Append(string.Join(",", typeArguments.Select(typeArgument => typeArgument.GetNameForCSharp(_parsedInfo.Interfaces))));
                fullName.Append('>');
            }
            else
            {
                // There is a possibility that the type we are rendering is actually an interface that has one or more default type parameters.
                var typeAsInterface =
                    _parsedInfo.Interfaces.FirstOrDefault(interfaceInfo => interfaceInfo.Name == singleTypeInfo.Name);

                if (typeAsInterface != null && typeAsInterface.ExtractTypeParametersResult.TypeParameters.Any())
                {
                    fullName.Append('<');

                    foreach (var typeParameter in typeAsInterface.ExtractTypeParametersResult.TypeParameters)
                    {
                        fullName.Append(typeParameter.Default == null
                            ? "IJSObject"
                            : GetRenderedTypeName(typeParameter.Default));
                    }

                    fullName.Append('>');
                }
            }

            return fullName.ToString();
        }

        private TypeInfo ProcessTypeAliases(TypeInfo typeInfo)
        {
            // Anything that looks like a single type is a candidate for being an alias.
            if (typeInfo.Single == null)
            {
                return typeInfo;
            }

            while (true)
            {
                // FIXME: We are assuming that you can only type alias the most simple case for now.
                var typeAlias = _parsedInfo.TypeAliases
                    .FirstOrDefault(typeAlias => typeInfo.Single != null && typeAlias.Name == typeInfo.Single.Name);

                if (typeAlias == null)
                {
                    return typeInfo;
                }

                typeInfo = typeAlias.AliasType;
            }
        }
    }
}
