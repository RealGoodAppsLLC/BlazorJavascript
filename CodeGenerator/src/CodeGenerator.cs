using RealGoodApps.ValueImmutableCollections;
using System.Text;
using RealGoodApps.BlazorJavascript.CodeGenerator.Models;

namespace RealGoodApps.BlazorJavascript.CodeGenerator
{
    public class CodeGenerator
    {
        private readonly ParsedInfo _parsedInfo;
        private readonly string _outputDirectory;

        public CodeGenerator(
            ParsedInfo parsedInfo,
            string outputDirectory)
        {
            _parsedInfo = parsedInfo;
            _outputDirectory = outputDirectory;
        }

        public int InterfaceCount { get; private set; }
        public int GlobalCount { get; private set; }
        public int PrototypeCount { get; private set; }
        public int ConstructorImplementationCount { get; private set; }
        public int MethodImplementationCount { get; private set; }
        public int PropertyImplementationCount { get; private set; }
        public int InterfaceConstructorCount { get; private set; }
        public int InterfaceMethodCount { get; private set; }
        public int InterfacePropertyCount { get; private set; }
        public int AppendedGlobalsCount { get; private set; }

        public void Generate()
        {
            foreach (var interfaceInfo in _parsedInfo.Interfaces)
            {
                var contents = GenerateInterfaceFileContents(
                    interfaceInfo.Name,
                    interfaceInfo.ExtractTypeParametersResult,
                    interfaceInfo.ExtendsList,
                    interfaceInfo.Body,
                    interfaceInfo.Name == GetGlobalThisInterfaceName());

                var interfaceOutputPath = Path.Combine(
                    _outputDirectory,
                    "Interfaces",
                    $"I{interfaceInfo.Name}.cs");

                if (File.Exists(interfaceOutputPath))
                {
                    throw new Exception($"File already exists: {interfaceOutputPath}");
                }

                File.WriteAllText(interfaceOutputPath, contents);

                var prototypeContents = GeneratePrototypeFileContents(interfaceInfo, interfaceInfo.Name == GetGlobalThisInterfaceName());

                var prototypeOutputPath = Path.Combine(
                    _outputDirectory,
                    "Prototypes",
                    $"{interfaceInfo.Name}.cs");

                if (File.Exists(prototypeOutputPath))
                {
                    throw new Exception($"File already exists: {prototypeOutputPath}");
                }

                File.WriteAllText(prototypeOutputPath, prototypeContents);
            }

            var globalsDefinedOutside = GetGlobalsDefinedOutsideOfGlobalThisInterface();

            foreach (var globalDefinedOutside in globalsDefinedOutside)
            {
                var contents = GenerateGlobalVariableFileContents(globalDefinedOutside);

                var globalVariableOutputPath = Path.Combine(
                    _outputDirectory,
                    "Globals",
                    $"{globalDefinedOutside.GlobalVariableInfo.Name}Global.cs");

                if (File.Exists(globalVariableOutputPath))
                {
                    throw new Exception($"File already exists: {globalVariableOutputPath}");
                }

                File.WriteAllText(globalVariableOutputPath, contents);

                if (globalDefinedOutside.GlobalVariableInfo.InlineInterface != null)
                {
                    var inlineInterfaceContents = GenerateInterfaceFileContents(
                        $"{globalDefinedOutside.GlobalVariableInfo.Name}Global",
                        null,
                        ValueImmutableList.Create<TypeInfo>(),
                        globalDefinedOutside.GlobalVariableInfo.InlineInterface,
                        false);

                    var inlineInterfaceOutputPath = Path.Combine(
                        _outputDirectory,
                        "Interfaces",
                        $"I{globalDefinedOutside.GlobalVariableInfo.Name}Global.cs");

                    if (File.Exists(inlineInterfaceOutputPath))
                    {
                        throw new Exception($"File already exists: {inlineInterfaceOutputPath}");
                    }

                    File.WriteAllText(inlineInterfaceOutputPath, inlineInterfaceContents);
                }
            }
        }

        private string GenerateInterfaceFileContents(
            string interfaceName,
            ExtractTypeParametersResult? extractTypeParametersResult,
            ValueImmutableList<TypeInfo> interfaceExtendsList,
            InterfaceBodyInfo interfaceBodyInfo,
            bool isGlobalThis)
        {
            InterfaceCount++;

            var stringBuilder = new StringBuilder();

            stringBuilder.AppendLine("/// <auto-generated />");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.Attributes;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.BuiltIns;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.GlobalVariables;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.Prototypes;");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("namespace RealGoodApps.BlazorJavascript.Interop.Interfaces");
            stringBuilder.AppendLine("{");

            var genericCarrots = string.Empty;

            if (extractTypeParametersResult?.TypeParameters.Any() == true)
            {
                genericCarrots = $"<{string.Join(",", extractTypeParametersResult.TypeParameters.Select(_ => string.Empty))}>";
            }

            stringBuilder.AppendLine($"{Indent(1)}[JSObjectConstructor(typeof({interfaceName}{genericCarrots}))]");
            stringBuilder.Append($"{Indent(1)}public interface I{interfaceName}");

            if (extractTypeParametersResult != null)
            {
                stringBuilder.Append(ExtractTypeParametersString(extractTypeParametersResult));
            }

            var extendsList = interfaceExtendsList
                .Select(extendTypeInfo => extendTypeInfo)
                .Where(extendTypeInfo => extendTypeInfo.Single != null)
                .Select(extendedTypeInfo => GetRenderedTypeName(ProcessTypeInformation(extendedTypeInfo)))
                .Append("IJSObject")
                .ToValueImmutableList();
            stringBuilder.Append($" : {string.Join(", ", extendsList)}");
            stringBuilder.Append(Environment.NewLine);

            stringBuilder.AppendLine(Indent(1) + "{");

            // We only want constructors that come from the interface body, ignoring the extends list.
            var constructors = GetConstructorsFromInterfaceBody(
                interfaceBodyInfo,
                extractTypeParametersResult,
                ValueImmutableList.Create<TypeInfo>(),
                ValueImmutableList.Create<InterfaceInfo>(),
                null);

            foreach (var (_, constructorInfo) in constructors)
            {
                InterfaceConstructorCount++;

                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));
                RenderConstructorBeginning(stringBuilder, constructorInfo, string.Empty);
                stringBuilder.Append(';');
                stringBuilder.Append(Environment.NewLine);
            }

            // We only want methods that come from the interface body, ignoring the extends list.
            var methods = GetMethodsFromInterfaceBody(
                interfaceBodyInfo,
                extractTypeParametersResult,
                ValueImmutableList.Create<TypeInfo>(),
                ValueImmutableList.Create<InterfaceInfo>(),
                null);

            foreach (var (_, methodInfo) in methods)
            {
                InterfaceMethodCount++;

                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));
                RenderMethodBeginning(stringBuilder, methodInfo, string.Empty);
                stringBuilder.Append(';');
                stringBuilder.Append(Environment.NewLine);
            }

            // Similar to above, we only want properties that come from the interface body, ignoring the extends list.
            var properties = GetPropertiesFromInterfaceBody(
                interfaceBodyInfo,
                extractTypeParametersResult,
                ValueImmutableList.Create<TypeInfo>(),
                ValueImmutableList.Create<InterfaceInfo>(),
                null);

            foreach (var (_, propertyInfo) in properties)
            {
                InterfacePropertyCount++;

                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));
                RenderPropertyBeginning(stringBuilder, propertyInfo, string.Empty);
                stringBuilder.Append(" { get; ");
                if (!propertyInfo.IsReadonly)
                {
                    stringBuilder.Append("set; ");
                }

                stringBuilder.Append('}');
                stringBuilder.Append(Environment.NewLine);
            }

            if (isGlobalThis)
            {
                AppendGlobalsToInterface(stringBuilder);
            }

            stringBuilder.AppendLine(Indent(1) + "}");
            stringBuilder.AppendLine("}");

            return stringBuilder.ToString();
        }

        private void AppendGlobalsToInterface(StringBuilder stringBuilder)
        {
            var globalsDefinedOutside = GetGlobalsDefinedOutsideOfGlobalThisInterface();

            foreach (var globalDefinedOutside in globalsDefinedOutside)
            {
                AppendedGlobalsCount++;

                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));
                stringBuilder.Append(globalDefinedOutside.InterfaceTypeName);
                stringBuilder.Append(' ');
                stringBuilder.Append(globalDefinedOutside.GlobalVariableInfo.Name);
                stringBuilder.Append(" { get; }");
                stringBuilder.Append(Environment.NewLine);
            }
        }

        private void AppendGlobalsToPrototype(StringBuilder stringBuilder)
        {
            var globalsDefinedOutside = GetGlobalsDefinedOutsideOfGlobalThisInterface();

            foreach (var globalDefinedOutside in globalsDefinedOutside)
            {
                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.AppendLine(Indent(2) + $"{globalDefinedOutside.InterfaceTypeName} IWindow.{globalDefinedOutside.GlobalVariableInfo.Name}");
                stringBuilder.AppendLine(Indent(2) + "{");

                GeneratePropertyGetter(
                    stringBuilder,
                    globalDefinedOutside.GlobalVariableInfo.Name,
                    globalDefinedOutside.InterfaceTypeName);

                stringBuilder.AppendLine(Indent(2) + "}");
            }
        }

        private static void GeneratePropertyGetter(
            StringBuilder stringBuilder,
            string propertyName,
            string propertyType)
        {
            stringBuilder.AppendLine(Indent(3) + "get");
            stringBuilder.AppendLine(Indent(3) + "{");

            stringBuilder.AppendLine(Indent(4) + $"return this.GetPropertyOfObject<{propertyType}>(\"{propertyName}\");");

            stringBuilder.AppendLine(Indent(3) + "}");
        }

        private static string ExtractTypeParametersString(ExtractTypeParametersResult extractTypeParametersResult)
        {
            var stringBuilder = new StringBuilder();

            if (extractTypeParametersResult.TypeParameters.Any())
            {
                stringBuilder.Append('<');

                stringBuilder.Append(string.Join(", ", extractTypeParametersResult.TypeParameters
                    .Select(typeParameter => typeParameter.Name)));

                stringBuilder.Append('>');
            }

            return stringBuilder.ToString();
        }

        private string GetPrefixTypeNameForInterfaceSymbolImplementations(InterfaceInfo interfaceInfo)
        {
            var stringBuilder = new StringBuilder();

            var typeParametersString = ExtractTypeParametersString(interfaceInfo.ExtractTypeParametersResult);
            stringBuilder.Append($"I{interfaceInfo.Name}{typeParametersString}");

            return stringBuilder.ToString();
        }

        private void RenderConstructorBeginning(
            StringBuilder stringBuilder,
            ConstructorInfo constructorInfo,
            string prefixTypeName)
        {
            stringBuilder.Append(GetRenderedTypeName(ProcessTypeInformation(constructorInfo.ReturnType)));
            stringBuilder.Append(' ');

            if (!string.IsNullOrWhiteSpace(prefixTypeName))
            {
                stringBuilder.Append($"{prefixTypeName}.");
            }

            stringBuilder.Append(constructorInfo.GetNameForCSharp());

            stringBuilder.Append('(');

            var isFirst = true;

            foreach (var parameterInfo in constructorInfo.Parameters)
            {
                if (!isFirst)
                {
                    stringBuilder.Append(", ");
                }

                stringBuilder.Append(GetRenderedTypeName(ProcessTypeInformation(parameterInfo.Type)));
                stringBuilder.Append(' ');
                stringBuilder.Append(parameterInfo.GetNameForCSharp());
                isFirst = false;
            }

            stringBuilder.Append(')');
        }

        private void RenderMethodBeginning(
            StringBuilder stringBuilder,
            MethodInfo methodInfo,
            string prefixTypeName)
        {
            stringBuilder.Append(GetRenderedTypeName(ProcessTypeInformation(methodInfo.ReturnType)));
            stringBuilder.Append(' ');

            if (!string.IsNullOrWhiteSpace(prefixTypeName))
            {
                stringBuilder.Append($"{prefixTypeName}.");
            }

            stringBuilder.Append(methodInfo.GetNameForCSharp());

            stringBuilder.Append('(');

            var isFirst = true;

            foreach (var parameterInfo in methodInfo.Parameters)
            {
                if (!isFirst)
                {
                    stringBuilder.Append(", ");
                }

                stringBuilder.Append(GetRenderedTypeName(ProcessTypeInformation(parameterInfo.Type)));
                stringBuilder.Append(' ');
                stringBuilder.Append(parameterInfo.GetNameForCSharp());
                isFirst = false;
            }

            stringBuilder.Append(')');
        }

        private void RenderPropertyBeginning(
            StringBuilder stringBuilder,
            PropertyInfo propertyInfo,
            string prefixTypeName)
        {
            stringBuilder.Append(GetRenderedTypeName(ProcessTypeInformation(propertyInfo.Type)));
            stringBuilder.Append(' ');

            if (!string.IsNullOrWhiteSpace(prefixTypeName))
            {
                stringBuilder.Append($"{prefixTypeName}.");
            }

            stringBuilder.Append(propertyInfo.GetNameForCSharp());
        }

        public enum CollisionType
        {
            None,
            SameParameters,
            Equal,
        }

        private CollisionType GetCollisionType(
            MethodInfo subject,
            MethodInfo other)
        {
            var subjectParametersProcessed = subject.Parameters
                .Select(p => ProcessTypeInformation(p.Type))
                .ToValueImmutableList();

            var otherParametersProcessed = other.Parameters
                .Select(p => ProcessTypeInformation(p.Type))
                .ToValueImmutableList();

            if (subject.Name != other.Name
                || !subjectParametersProcessed.Equals(otherParametersProcessed)
                || subject.ExtractTypeParametersResult.TypeParameters.Count != other.ExtractTypeParametersResult.TypeParameters.Count)
            {
                return CollisionType.None;
            }

            var subjectReturnTypeProcessed = ProcessTypeInformation(subject.ReturnType);
            var otherReturnTypeProcessed = ProcessTypeInformation(other.ReturnType);

            return subjectReturnTypeProcessed == otherReturnTypeProcessed
                ? CollisionType.Equal
                : CollisionType.SameParameters;
        }

        private ValueImmutableList<(InterfaceInfo? OwnerInterface, MethodInfo MethodInfo)> GetMethodsFromInterfaceBody(
            InterfaceBodyInfo interfaceBodyInfo,
            ExtractTypeParametersResult? extractTypeParametersResult,
            ValueImmutableList<TypeInfo> extendsList,
            ValueImmutableList<InterfaceInfo> alreadyProcessedInterfaces,
            InterfaceInfo? ownerInterface)
        {
            var methods = new List<(InterfaceInfo? InterfaceInfo, MethodInfo MethodInfo)>();

            if (extendsList.Any())
            {
                foreach (var extendTypeInfo in extendsList)
                {
                    // FIXME: I am probably missing something, but when we process type aliases here it causes problems in detecting methods.
                    if (extendTypeInfo.Single == null)
                    {
                        continue;
                    }

                    var extendInterfaceInfo = _parsedInfo.Interfaces.FirstOrDefault(i => i.Name == extendTypeInfo.Single.Name);

                    if (extendInterfaceInfo == null
                        || alreadyProcessedInterfaces.Any(i => i.Name == extendInterfaceInfo.Name))
                    {
                        continue;
                    }

                    alreadyProcessedInterfaces = alreadyProcessedInterfaces.Add(extendInterfaceInfo);

                    methods.AddRange(GetMethodsFromInterfaceBody(
                        extendInterfaceInfo.Body,
                        extendInterfaceInfo.ExtractTypeParametersResult,
                        extendInterfaceInfo.ExtendsList,
                        alreadyProcessedInterfaces,
                        extendInterfaceInfo));
                }
            }

            if (extractTypeParametersResult != null && extractTypeParametersResult.TypeParameters.Any())
            {
                return methods.ToValueImmutableList();
            }

            foreach (var methodInfo in interfaceBodyInfo.Methods)
            {
                // FIXME: We are skipping any methods that are not simple enough for a 1 to 1 translation.
                //        For example, nothing with generics, union types, intersection types, or function parameters.
                if (methodInfo.ExtractTypeParametersResult.TypeParameters.Any())
                {
                    continue;
                }

                if (IsFinalTypeTooComplexToRender(ProcessTypeInformation(methodInfo.ReturnType)))
                {
                    continue;
                }

                if (methodInfo.Parameters.Any(parameterInfo => IsFinalTypeTooComplexToRender(ProcessTypeInformation(parameterInfo.Type))))
                {
                    continue;
                }

                var collisionType = CollisionType.None;
                int collisionCount = 0;

                foreach (var (existingInterface, existingMethod) in methods)
                {
                    if (existingInterface != ownerInterface)
                    {
                        continue;
                    }

                    var existingCollisionType = GetCollisionType(methodInfo, existingMethod);

                    if (existingCollisionType != CollisionType.None)
                    {
                        collisionType = existingCollisionType;
                        collisionCount++;
                    }
                }

                if (collisionType == CollisionType.None)
                {
                    methods.Add((ownerInterface, methodInfo));
                }
                else if (collisionType == CollisionType.SameParameters)
                {
                    var collisionString = new StringBuilder();
                    for (var c = 0; c < collisionCount; c++)
                    {
                        collisionString.Append('_');
                    }

                    methods.Add((ownerInterface, methodInfo with
                    {
                        Name = methodInfo.Name + collisionString,
                    }));
                }
            }

            return methods.ToValueImmutableList();
        }

        private ValueImmutableList<(InterfaceInfo? OwnerInterface, ConstructorInfo ConstructorInfo)> GetConstructorsFromInterfaceBody(
            InterfaceBodyInfo interfaceBodyInfo,
            ExtractTypeParametersResult? extractTypeParametersResult,
            ValueImmutableList<TypeInfo> extendsList,
            ValueImmutableList<InterfaceInfo> alreadyProcessedInterfaces,
            InterfaceInfo? ownerInterface)
        {
            var constructors = new List<(InterfaceInfo? InterfaceInfo, ConstructorInfo ConstructorInfo)>();

            if (extendsList.Any())
            {
                foreach (var extendTypeInfo in extendsList)
                {
                    // FIXME: I am probably missing something, but when we process type aliases here it causes problems in detecting methods.
                    if (extendTypeInfo.Single == null)
                    {
                        continue;
                    }

                    var extendInterfaceInfo = _parsedInfo.Interfaces.FirstOrDefault(i => i.Name == extendTypeInfo.Single.Name);

                    if (extendInterfaceInfo == null
                        || alreadyProcessedInterfaces.Any(i => i.Name == extendInterfaceInfo.Name))
                    {
                        continue;
                    }

                    alreadyProcessedInterfaces = alreadyProcessedInterfaces.Add(extendInterfaceInfo);

                    constructors.AddRange(GetConstructorsFromInterfaceBody(
                        extendInterfaceInfo.Body,
                        extendInterfaceInfo.ExtractTypeParametersResult,
                        extendInterfaceInfo.ExtendsList,
                        alreadyProcessedInterfaces,
                        extendInterfaceInfo));
                }
            }

            if (extractTypeParametersResult != null && extractTypeParametersResult.TypeParameters.Any())
            {
                return constructors.ToValueImmutableList();
            }

            foreach (var constructorInfo in interfaceBodyInfo.Constructors)
            {
                // FIXME: We are skipping any constructors that are not simple enough for a 1 to 1 translation.
                //        For example, nothing with generics, union types, intersection types, or function parameters.
                if (constructorInfo.ExtractTypeParametersResult.TypeParameters.Any())
                {
                    continue;
                }

                if (IsFinalTypeTooComplexToRender(ProcessTypeInformation(constructorInfo.ReturnType)))
                {
                    continue;
                }

                if (constructorInfo.Parameters.Any(parameterInfo => IsFinalTypeTooComplexToRender(ProcessTypeInformation(parameterInfo.Type))))
                {
                    continue;
                }

                constructors.Add((ownerInterface, constructorInfo));
            }

            return constructors.ToValueImmutableList();
        }

        private ValueImmutableList<(InterfaceInfo? OwnerInterface, PropertyInfo PropertyInfo)> GetPropertiesFromInterfaceBody(
            InterfaceBodyInfo interfaceBodyInfo,
            ExtractTypeParametersResult? extractTypeParametersResult,
            ValueImmutableList<TypeInfo> extendsList,
            ValueImmutableList<InterfaceInfo> alreadyProcessedInterfaces,
            InterfaceInfo? ownerInterface)
        {
            var properties = new List<(InterfaceInfo? OwnerInterface, PropertyInfo PropertyInfo)>();

            foreach (var extendTypeInfo in extendsList)
            {
                if (extendTypeInfo.Single == null)
                {
                    continue;
                }

                var extendInterfaceInfo = _parsedInfo.Interfaces.FirstOrDefault(i => i.Name == extendTypeInfo.Single.Name);

                if (extendInterfaceInfo == null
                    || alreadyProcessedInterfaces.Any(i => i.Name == extendInterfaceInfo.Name))
                {
                    continue;
                }

                alreadyProcessedInterfaces = alreadyProcessedInterfaces.Add(extendInterfaceInfo);

                properties.AddRange(GetPropertiesFromInterfaceBody(
                    extendInterfaceInfo.Body,
                    extendInterfaceInfo.ExtractTypeParametersResult,
                    extendInterfaceInfo.ExtendsList,
                    alreadyProcessedInterfaces,
                    extendInterfaceInfo));
            }

            if (extractTypeParametersResult != null && extractTypeParametersResult.TypeParameters.Any())
            {
                return properties.ToValueImmutableList();
            }

            foreach (var propertyInfo in interfaceBodyInfo.Properties)
            {
                // FIXME: We are skipping any properties that are not simple enough for a 1 to 1 translation.
                //        For example, nothing with generics, union types, intersection types, or function parameters.
                if (IsFinalTypeTooComplexToRender(ProcessTypeInformation(propertyInfo.Type)))
                {
                    continue;
                }

                properties.Add((ownerInterface, propertyInfo));
            }

            return properties.ToValueImmutableList();
        }

        private ValueImmutableList<GetAccessorInfo> GetGetAccessorsFromInterfaceRecursively(InterfaceInfo interfaceInfo)
        {
            var allGetAccessors = new List<GetAccessorInfo>();

            foreach (var extendInfo in interfaceInfo.ExtendsList)
            {
                if (extendInfo.Single == null)
                {
                    continue;
                }

                var extendInterfaceInfo = _parsedInfo.Interfaces.FirstOrDefault(i => i.Name == extendInfo.Single.Name);

                if (extendInterfaceInfo == null)
                {
                    continue;
                }

                allGetAccessors.AddRange(GetGetAccessorsFromInterfaceRecursively(extendInterfaceInfo));
            }

            allGetAccessors.AddRange(interfaceInfo.Body.GetAccessors);
            return allGetAccessors.ToValueImmutableList();
        }

        private string GenerateGlobalVariableFileContents(GlobalDefinedOutsideOfGlobalThisInterface globalDefinedOutside)
        {
            GlobalCount++;

            var stringBuilder = new StringBuilder();

            var fullGlobalName = $"{globalDefinedOutside.GlobalVariableInfo.Name}Global";

            stringBuilder.AppendLine("/// <auto-generated />");
            stringBuilder.AppendLine("using System;");
            stringBuilder.AppendLine("using Microsoft.JSInterop;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.BuiltIns;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.Extensions;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.Interfaces;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.Prototypes;");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("namespace RealGoodApps.BlazorJavascript.Interop.GlobalVariables");
            stringBuilder.AppendLine("{");
            stringBuilder.AppendLine(Indent(1) + $"public class {fullGlobalName} : {globalDefinedOutside.InterfaceTypeName}, IJSObject");
            stringBuilder.AppendLine(Indent(1) + "{");

            stringBuilder.Append(GenerateJSObjectSubtypeBoilerPlate(fullGlobalName));

            stringBuilder.Append(GenerateInterfaceImplementations(
                globalDefinedOutside.InterfaceTypeName,
                globalDefinedOutside.InterfaceBodyInfo,
                globalDefinedOutside.ExtractTypeParametersResult,
                globalDefinedOutside.ExtendsList));

            stringBuilder.AppendLine(Indent(1) + "}");
            stringBuilder.AppendLine("}");

            return stringBuilder.ToString();
        }

        private static string Indent(int levels)
        {
            var indentationBuilder = new StringBuilder();

            for (int level = 1; level <= levels; level++)
            {
                indentationBuilder.Append("    ");
            }

            return indentationBuilder.ToString();
        }

        private string GeneratePrototypeFileContents(InterfaceInfo interfaceInfo, bool isGlobalThis)
        {
            PrototypeCount++;

            var stringBuilder = new StringBuilder();

            var typeParametersString = ExtractTypeParametersString(interfaceInfo.ExtractTypeParametersResult);

            stringBuilder.AppendLine("/// <auto-generated />");
            stringBuilder.AppendLine("using System;");
            stringBuilder.AppendLine("using Microsoft.JSInterop;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.BuiltIns;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.Extensions;");
            stringBuilder.AppendLine("using RealGoodApps.BlazorJavascript.Interop.Interfaces;");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("namespace RealGoodApps.BlazorJavascript.Interop.Prototypes");
            stringBuilder.AppendLine("{");
            stringBuilder.AppendLine($"{Indent(1)}public class {interfaceInfo.Name}{typeParametersString} : I{interfaceInfo.Name}{typeParametersString}, IJSObject");
            stringBuilder.AppendLine(Indent(1) + "{");

            stringBuilder.Append(GenerateJSObjectSubtypeBoilerPlate($"{interfaceInfo.Name}"));

            stringBuilder.Append(GenerateInterfaceImplementations(
                GetPrefixTypeNameForInterfaceSymbolImplementations(interfaceInfo),
                interfaceInfo.Body,
                interfaceInfo.ExtractTypeParametersResult,
                interfaceInfo.ExtendsList));

            if (isGlobalThis)
            {
                AppendGlobalsToPrototype(stringBuilder);
            }

            stringBuilder.AppendLine(Indent(1) + "}");
            stringBuilder.AppendLine("}");

            return stringBuilder.ToString();
        }

        private string GenerateInterfaceImplementations(
            string defaultTypePrefix,
            InterfaceBodyInfo interfaceBodyInfo,
            ExtractTypeParametersResult? extractTypeParametersResult,
            ValueImmutableList<TypeInfo> extendsList)
        {
            var stringBuilder = new StringBuilder();

            var constructors = GetConstructorsFromInterfaceBody(
                interfaceBodyInfo,
                extractTypeParametersResult,
                extendsList,
                ValueImmutableList.Create<InterfaceInfo>(),
                null);

            foreach (var (constructorInterfaceInfo, constructorInfo) in constructors)
            {
                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));

                var prefix = constructorInterfaceInfo == null
                    ? defaultTypePrefix
                    : GetPrefixTypeNameForInterfaceSymbolImplementations(constructorInterfaceInfo);

                ConstructorImplementationCount++;

                RenderConstructorBeginning(stringBuilder, constructorInfo, prefix);
                stringBuilder.Append(Environment.NewLine);
                stringBuilder.Append(Indent(2) + "{");
                stringBuilder.Append(Environment.NewLine);

                var parametersString = string.Join(", ", constructorInfo.Parameters.Select(p => p.GetNameForCSharp()));
                var processedReturnType = ProcessTypeInformation(constructorInfo.ReturnType);
                var returnRenderedTypeName = GetRenderedTypeName(processedReturnType);

                stringBuilder.AppendLine(Indent(3) + $"return this.CallConstructor<{returnRenderedTypeName}>({parametersString});");

                stringBuilder.Append(Indent(2) + "}");
                stringBuilder.Append(Environment.NewLine);
            }

            var methods = GetMethodsFromInterfaceBody(
                interfaceBodyInfo,
                extractTypeParametersResult,
                extendsList,
                ValueImmutableList.Create<InterfaceInfo>(),
                null);

            foreach (var (methodInterfaceInfo, methodInfo) in methods)
            {
                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));

                var prefix = methodInterfaceInfo == null
                    ? defaultTypePrefix
                    : GetPrefixTypeNameForInterfaceSymbolImplementations(methodInterfaceInfo);

                MethodImplementationCount++;

                RenderMethodBeginning(stringBuilder, methodInfo, prefix);
                stringBuilder.Append(Environment.NewLine);
                stringBuilder.Append(Indent(2) + "{");
                stringBuilder.Append(Environment.NewLine);

                var parametersString = string.Join(", ", methodInfo.Parameters.Select(p => p.GetNameForCSharp()));
                var parametersPrefix = string.IsNullOrWhiteSpace(parametersString) ? string.Empty : ", ";
                var processedReturnType = ProcessTypeInformation(methodInfo.ReturnType);
                var returnRenderedTypeName = GetRenderedTypeName(processedReturnType);

                stringBuilder.AppendLine(Indent(3) + $"var functionObj = this.GetPropertyOfObject<JSFunction>(\"{methodInfo.Name}\");");

                if (returnRenderedTypeName == "void")
                {
                    stringBuilder.AppendLine(Indent(3) + $"functionObj.InvokeVoid(this{parametersPrefix}{parametersString});");
                }
                else
                {
                    stringBuilder.AppendLine(Indent(3) + $"return functionObj.Invoke<{returnRenderedTypeName}>(this{parametersPrefix}{parametersString});");
                }

                stringBuilder.Append(Indent(2) + "}");
                stringBuilder.Append(Environment.NewLine);
            }

            var properties = GetPropertiesFromInterfaceBody(
                interfaceBodyInfo,
                extractTypeParametersResult,
                extendsList,
                ValueImmutableList.Create<InterfaceInfo>(),
                null);

            foreach (var (propertyInterfaceInfo, propertyInfo) in properties)
            {
                // FIXME: It would be nice to carry over any comments from the TypeScript definitions.
                stringBuilder.Append(Indent(2));

                var prefix = propertyInterfaceInfo == null
                    ? defaultTypePrefix
                    : GetPrefixTypeNameForInterfaceSymbolImplementations(propertyInterfaceInfo);

                PropertyImplementationCount++;

                RenderPropertyBeginning(stringBuilder, propertyInfo, prefix);
                stringBuilder.Append(Environment.NewLine);
                stringBuilder.AppendLine(Indent(2) + "{");

                var returnRenderedTypeName = GetRenderedTypeName(ProcessTypeInformation(propertyInfo.Type));

                GeneratePropertyGetter(
                    stringBuilder,
                    propertyInfo.Name,
                    returnRenderedTypeName);

                if (!propertyInfo.IsReadonly)
                {
                    stringBuilder.AppendLine();
                    stringBuilder.AppendLine(Indent(3) + "set");
                    stringBuilder.AppendLine(Indent(3) + "{");
                    stringBuilder.AppendLine(Indent(4) + $"this.SetPropertyOfObject(\"{propertyInfo.Name}\", value);");
                    stringBuilder.AppendLine(Indent(3) + "}");
                }

                stringBuilder.AppendLine(Indent(2) + "}");
            }

            return stringBuilder.ToString();
        }

        private static string GenerateJSObjectSubtypeBoilerPlate(string className)
        {
            var stringBuilder = new StringBuilder();

            stringBuilder.AppendLine(Indent(2) + $"public {className}(IJSInProcessRuntime jsInProcessRuntime, IJSObjectReference jsObjectReference)");
            stringBuilder.AppendLine(Indent(2) + "{");
            stringBuilder.AppendLine(Indent(3) + "Runtime = jsInProcessRuntime;");
            stringBuilder.AppendLine(Indent(3) + "ObjectReference = jsObjectReference;");
            stringBuilder.AppendLine(Indent(2) + "}");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine(Indent(2) + "public IJSInProcessRuntime Runtime { get; }");
            stringBuilder.AppendLine(Indent(2) + "public IJSObjectReference ObjectReference { get; }");

            return stringBuilder.ToString();
        }

        private bool IsFinalTypeTooComplexToRender(ProcessedTypeInfo parameterInfoType)
        {
            // FIXME: Eventually, this method shouldn't really exist. It is just used to prevent us from having to handle complex type cases right now.
            if (parameterInfoType.TypeInfo.Array != null)
            {
                // We know that the array must have been processed too, so this is safe.
                return IsFinalTypeTooComplexToRender(new ProcessedTypeInfo(parameterInfoType.TypeInfo.Array));
            }

            if (parameterInfoType.TypeInfo.Union != null)
            {
                return false;
            }

            return parameterInfoType.TypeInfo.Single == null
                   || parameterInfoType.TypeInfo.Single.IsUnhandled
                   || parameterInfoType.TypeInfo.Single.TypeArguments.Any(typeArgument => IsFinalTypeTooComplexToRender(new ProcessedTypeInfo(typeArgument)))
                   || string.IsNullOrWhiteSpace(parameterInfoType.TypeInfo.Single.Name);
        }

        private string GetRenderedTypeName(ProcessedTypeInfo processedTypeInfo)
        {
            if (processedTypeInfo.TypeInfo.Array != null)
            {
                var fullArrayName = new StringBuilder();
                fullArrayName.Append("IJSArray");

                fullArrayName.Append('<');
                fullArrayName.Append(GetRenderedTypeName(new ProcessedTypeInfo(processedTypeInfo.TypeInfo.Array)));
                fullArrayName.Append('>');

                return fullArrayName.ToString();
            }

            if (processedTypeInfo.TypeInfo.Union != null)
            {
                return "IJSObject";
            }

            var singleTypeInfo = processedTypeInfo.TypeInfo.Single;

            if (singleTypeInfo == null)
            {
                throw new Exception("The type name can not be rendered properly due to complexity.");
            }

            var fullName = new StringBuilder();
            fullName.Append(singleTypeInfo.GetNameForCSharp(_parsedInfo.Interfaces));

            var typeArguments = singleTypeInfo
                .TypeArguments
                .WhereNotNull()
                .ToValueImmutableList();

            if (typeArguments.Any())
            {
                fullName.Append('<');
                fullName.Append(string.Join(",", typeArguments.Select(typeArgument => GetRenderedTypeName(new ProcessedTypeInfo(typeArgument)))));
                fullName.Append('>');
            }
            else
            {
                // There is a possibility that the type we are rendering is actually an interface that has one or more default type parameters.
                var typeAsInterface =
                    _parsedInfo.Interfaces.FirstOrDefault(interfaceInfo => interfaceInfo.Name == singleTypeInfo.Name);

                if (typeAsInterface != null && typeAsInterface.ExtractTypeParametersResult.TypeParameters.Any())
                {
                    fullName.Append('<');

                    var isFirst = true;

                    foreach (var typeParameter in typeAsInterface.ExtractTypeParametersResult.TypeParameters)
                    {
                        if (!isFirst)
                        {
                            fullName.Append(", ");
                        }

                        fullName.Append(typeParameter.Default == null
                            ? "IJSObject"
                            : GetRenderedTypeName(ProcessTypeInformation(typeParameter.Default)));

                        isFirst = false;
                    }

                    fullName.Append('>');
                }
            }

            return fullName.ToString();
        }

        ProcessedTypeInfo ProcessTypeInformation(TypeInfo typeInfo)
        {
            typeInfo = RewriteNullsForUnion(typeInfo);

            // Process arrays!
            if (typeInfo.Array != null)
            {
                // FIXME: Does it make sense to convert `ProcessTypeAliasesAndRewriteNulls` into a public and
                //        internal version to prevent this awkwardness?
                var processedArrayItemType = ProcessTypeInformation(typeInfo.Array);

                typeInfo = typeInfo with
                {
                    Array = processedArrayItemType.TypeInfo,
                };
            }

            // Anything that looks like a single type is a candidate for being an alias.
            if (typeInfo.Single == null)
            {
                return new ProcessedTypeInfo(typeInfo);
            }

            var processedTypeArguments = typeInfo.Single.TypeArguments
                .Select(ProcessTypeInformation)
                .Select(processedTypeArgument => processedTypeArgument.TypeInfo)
                .ToValueImmutableList();

            typeInfo = typeInfo with
            {
                Single = typeInfo.Single with
                {
                    TypeArguments = processedTypeArguments,
                },
            };

            var anyTypeAliases = false;
            while (true)
            {
                // FIXME: We are assuming that you can only type alias the most simple case for now.
                var typeAlias = _parsedInfo.TypeAliases
                    .FirstOrDefault(typeAlias => typeInfo.Single != null && typeAlias.Name == typeInfo.Single.Name);

                if (typeAlias == null)
                {
                    return anyTypeAliases
                        ? ProcessTypeInformation(typeInfo)
                        : new ProcessedTypeInfo(typeInfo);
                }

                typeInfo = typeAlias.AliasType;
                anyTypeAliases = true;
            }
        }

        private TypeInfo RewriteNullsForUnion(TypeInfo typeInfo)
        {
            if (typeInfo.Union == null)
            {
                return typeInfo;
            }

            var finalTypeList = new List<TypeInfo>();

            foreach (var typeWithinUnion in typeInfo.Union.Types)
            {
                if (typeWithinUnion.Single == null
                    || typeWithinUnion.Single.Name != "null")
                {
                    finalTypeList.Add(typeWithinUnion);
                }
            }

            if (finalTypeList.Count == 1)
            {
                return finalTypeList.First();
            }

            // HACK: Replace unions with any (which will essentially equate to IJSObject).
            return new TypeInfo(
                null,
                null,
                null,
                new SingleTypeInfo(
                    "any",
                    null,
                    null,
                    null,
                    ValueImmutableList.Create<TypeInfo>(),
                    false),
                null,
                null);

            // return new TypeInfo(
            //     new UnionTypeInfo(finalTypeList.ToValueImmutableList()),
            //     null,
            //     null,
            //     null,
            //     null,
            //     null);
        }

        private sealed record GlobalDefinedOutsideOfGlobalThisInterface(
            GlobalVariableInfo GlobalVariableInfo,
            string InterfaceTypeName,
            InterfaceBodyInfo InterfaceBodyInfo,
            ExtractTypeParametersResult? ExtractTypeParametersResult,
            ValueImmutableList<TypeInfo> ExtendsList);

        private ValueImmutableList<GlobalDefinedOutsideOfGlobalThisInterface> GetGlobalsDefinedOutsideOfGlobalThisInterface()
        {
            var globalThisInterface = _parsedInfo.Interfaces.First(interfaceInfo => interfaceInfo.Name == GetGlobalThisInterfaceName());
            var allProperties = GetPropertiesFromInterfaceBody(
                globalThisInterface.Body,
                globalThisInterface.ExtractTypeParametersResult,
                globalThisInterface.ExtendsList,
                ValueImmutableList.Create<InterfaceInfo>(),
                null);
            var allWindowGetters = GetGetAccessorsFromInterfaceRecursively(globalThisInterface);

            var result = new List<GlobalDefinedOutsideOfGlobalThisInterface>();

            foreach (var globalVariableInfo in _parsedInfo.GlobalVariables)
            {
                // HACK: Let's exclude anything that was already defined in the `Window` interface.
                if (allProperties.Any(propertyDetails => propertyDetails.PropertyInfo.Name == globalVariableInfo.Name)
                    || allWindowGetters.Any(getAccessor => getAccessor.Name == globalVariableInfo.Name))
                {
                    continue;
                }

                if (globalVariableInfo.InlineInterface != null)
                {
                    result.Add(new GlobalDefinedOutsideOfGlobalThisInterface(
                        globalVariableInfo,
                        $"I{globalVariableInfo.Name}Global",
                        globalVariableInfo.InlineInterface,
                        null,
                        ValueImmutableList.Create<TypeInfo>()));

                    continue;
                }

                if (globalVariableInfo.Type == null)
                {
                    continue;
                }

                var processedFinalTypeInfo = ProcessTypeInformation(globalVariableInfo.Type);

                if (IsFinalTypeTooComplexToRender(processedFinalTypeInfo))
                {
                    continue;
                }

                var globalInterfaceType = _parsedInfo.Interfaces.FirstOrDefault(i => i.Name == processedFinalTypeInfo.TypeInfo.Single?.Name);

                if (globalInterfaceType == null)
                {
                    continue;
                }

                result.Add(new GlobalDefinedOutsideOfGlobalThisInterface(
                    globalVariableInfo,
                    GetPrefixTypeNameForInterfaceSymbolImplementations(globalInterfaceType),
                    globalInterfaceType.Body,
                    globalInterfaceType.ExtractTypeParametersResult,
                    globalInterfaceType.ExtendsList));
            }

            return result.ToValueImmutableList();
        }

        private string GetGlobalThisInterfaceName()
        {
            // FIXME: Right now, we know the globalThis is a `Window`, but we might not want to assume this
            //        in the future, especially if this code is used to generate bindings for libraries.
            return "Window";
        }
    }
}
